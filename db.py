#!/usr/bin/python

import config
import sqlalchemy as sa
from sqlalchemy.orm import sessionmaker, scoped_session
import progressbar
import time

# engine = sa.create_engine("sqlite:///data/db.sqlite3")
engine = sa.create_engine("mysql://root:@localhost/crawler", pool_size=config.THREADS_COUNT)
Session = scoped_session(sessionmaker(bind=engine))
global_session = Session()
connection = engine.connect()

def debug_print(msg):
    if config.DB_VERBOSE:
        print msg

"""
    Queries the database and returns found objects.

    Arguments:
        obj_class - the ORM class representing the needed table.
        list_of_queries - list of tuples of form (("k1", "v1"), ("k2", "v2"), ...),
            representing the queries.
    Returns:
        A dict{query: obj/False}, where keys are tuples described above and values
        are either the first object matching the query (object, s.t. for each i
        obj.ki == vi) or False if no object can be found.

    Comments:
        1. Apparently, executing many sql queries is a bottleneck. This is why
        we query all objects and filter them manually in code.
        2. For this function to work, obj_class should have a "sort_field" field
        defined.
        3. We use queries in tuple form, because dicts are not hashable :(
"""
def find_objects(obj_class, list_of_queries, session=global_session):
    def comp_func(obj, comp_args_tuple):
        # Convert args from tuple to dict.
        comp_args_dict = dict(comp_args_tuple)
        for k, v in comp_args_dict.iteritems():
            if getattr(obj, k) != v:
                return False
        return True

    # Get all rows from db.
    all_objects_list = session.query(obj_class).all()
    all_objects_dict = {}
    for x in all_objects_list:
        field = getattr(x, obj_class.sort_field)
        # Arrange them in a map, where value of the field "sort_field" is the key.
        all_objects_dict.setdefault(field, []).append(x)

    debug_print("Searching for objects in table: {0}".format(obj_class.__tablename__))
    if config.DB_VERBOSE:
        bar = progressbar.ProgressBar(maxval=len(list_of_queries))
        iterable = bar(list_of_queries)
    else:
        iterable = list_of_queries
    res = {}
    found_count = 0
    for q in iterable:
        res[q] = False
        field = dict(q)[obj_class.sort_field]
        if all_objects_dict.get(field) is None:
            continue
        for x in all_objects_dict[field]:
            if comp_func(x, q):
                found_count += 1
                res[q] = x
                break
    debug_print("Search done. Found {0}/{1} objects".format(found_count, len(list_of_queries)))
    return res

"""
    Stores objects, which are not in the db.

    Arguments:
        obj_class - see the description in find_objects.
        list_of_queries - see the description in find_objects.
        need_ids - flag specifying if the returned objects should have their
            ids set.

    Returns:
        Returns the dict{query: obj}, where obj is either found in the db
        (see find_objects) or newly created.
"""
def find_or_add_objects(obj_class, list_of_queries, need_ids=False, session=global_session):
    debug_print('=' * 80)
    debug_print("Finding/adding {0} objects to the table: {1}".format(
            len(list_of_queries), obj_class.__tablename__))
    search_res = find_objects(obj_class, list_of_queries, session)

    # key - the kwarg, for which the corresponding object was not found in db.
    # value - the position of x in list_of_queries.
    not_found = {x: i for i, x in enumerate(list_of_queries) if not search_res[x]}

    # same, but key is an object built from the kwarg
    debug_print("Have to add {0}/{1} objects".format(len(not_found),
            len(list_of_queries)))
    objects = {obj_class(**dict(x)): i for x, i in not_found.iteritems()}
    session.bulk_save_objects(objects.keys())
    session.commit()

    for x, i in objects.iteritems():
        search_res[list_of_queries[i]] = x
    if need_ids and len(not_found) > 0:
        # Apparently session.commit() does not update the ids of newly created
        # objects. To deal with it, we repeat the search step (it should work
        # fast enough).
        debug_print("Repeating the find step to populate object ids")
        debug_print('=' * 80)
        return find_objects(obj_class, list_of_queries, session)
    debug_print('=' * 80)
    return search_res

"""
    Works similar to find_or_add_objects, but for many-to-many (mtm) tables
    instead of ORM objects.

    Arguments:
        table - the mtm table.
        list_of_queries - list of tuples of form:
            ((first_column_name, first_id), (second_column_name), second_id))

    Returns:
        A tuple x, where:
            x[0] = number of first_ids inserted,
            x[1] = number of second_ids inserted.
"""
def find_or_add_for_mtm_table(table, list_of_queries):
    debug_print('=' * 80)
    rows = set([tuple(x) for x in engine.execute(table.select()).fetchall()])
    not_found = filter(lambda x: not (x[0][1], x[1][1]) in rows, list_of_queries)
    debug_print("Have to add {0}/{1} rows to table".format(len(not_found), len(list_of_queries)))
    conn = engine.connect()

    if config.DB_VERBOSE:
        CHUNK_SIZE = 10000
        bar = progressbar.ProgressBar(maxval=CHUNK_SIZE)
        for i in bar(xrange(0, len(not_found), CHUNK_SIZE)):
            #Done in chunks to facilitate execution tracking.
            conn.execute(table.insert(), [dict(x) for x in not_found[i:i+CHUNK_SIZE]])
    else:
        conn.execute(table.insert(), [dict(x) for x in not_found])

    debug_print('=' * 80)
    new_first_ids_count = len(set([x[0][1] for x in not_found]))
    new_second_ids_count = len(set([x[1][1] for x in not_found]))
    return (new_first_ids_count, new_second_ids_count)

def find_object_orm(obj_class, session=global_session, **kwargs):
    q = session.query(obj_class)
    for k, v in kwargs.iteritems():
        q = q.filter(getattr(obj_class, k) == v)
    return q.first()

def find_or_add_object_orm(obj_class, session=global_session, **kwargs):
    obj = find_object_orm(obj_class, session, **kwargs)
    if obj:
        return obj
    obj = obj_class(**kwargs)
    session.add(obj)
    session.commit()
    return obj
