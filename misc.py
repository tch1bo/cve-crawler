#!/usr/bin/python

import config
import datetime
import itertools
import json
import net
import os.path
import progressbar
import threading
import zipfile

# thread pool
from multiprocessing.dummy import Pool

def flatten_list(l):
    return list(itertools.chain(*l))

def unique(l):
    return list(set(l))

def find_in_list(l, value, default=-1):
    return next((i for i, x in enumerate(l) if x == value), default)

def repo_path(user, repo):
    return os.path.join(config.REPOS_DIR, user, repo)

def zip_path_for_year(year):
    return os.path.join(config.NIST_ZIP_DIR, year + '.zip')

def json_path_for_year(year):
    return os.path.join(config.NIST_JSON_DIR, "nvdcve-1.0-{0}.json".format(year))

def get_nist_feed_years():
    return [str(x) for x in xrange(2002, 2019)]

def should_update_nist():
    if not os.path.isfile(config.NIST_TIME_FILE):
        return True
    with open(config.NIST_TIME_FILE, 'r') as f:
        try:
            last = datetime.datetime.strptime(f.read(), config.DATE_TIME_FORMAT)
        except:
            return True
        delta = datetime.datetime.now() - last
        return delta.days > 1
    return True

def parallel_map(func, sequence, num_workers=config.THREADS_COUNT):
    pool = Pool(num_workers)
    result = pool.map(func, sequence)
    pool.close()
    pool.join()
    return result

def map_func(func, sequence, parallel, num_workers=config.THREADS_COUNT):
    if parallel:
        return parallel_map(func, sequence, num_workers=num_workers)
    return map(func, sequence)

def extract_zip(from_path, to_path):
    zip_ref = zipfile.ZipFile(from_path, 'r')
    zip_ref.extractall(to_path)
    zip_ref.close()

def update_nist(parallel=False):
    url_t = "https://static.nvd.nist.gov/feeds/json/cve/1.0/nvdcve-1.0-{0}.json.zip"
    years = get_nist_feed_years()
    print "Updating NIST feed"
    def year_handler(year):
        url = url_t.format(year)
        zip_path = zip_path_for_year(year)
        net.download_file(url, zip_path)
        extract_zip(zip_path, config.NIST_JSON_DIR)
    map_func(year_handler, years, parallel)

    with open(config.NIST_TIME_FILE, 'w') as f:
        now = datetime.datetime.now()
        f.write(now.strftime(config.DATE_TIME_FORMAT))
    print "Done updating NIST feed"
    print "-" * 80

def crawl_nist_files(items_handler, parallel=False):
    if should_update_nist():
        update_nist(parallel=True)
    else:
        print "Nist feeds are up to date"
    years = get_nist_feed_years()
    crawl_nist_files.bar = KnownLengthBar(len(years), parallel=parallel)

    def year_handler(year):
        path = json_path_for_year(year)
        with open(path, "r") as f:
            json_obj = json.load(f)
            cve_items = json_obj["CVE_Items"]
            result = items_handler(cve_items)
        crawl_nist_files.bar.update()
        return result

    num_workers = min(len(years), config.THREADS_COUNT)
    return map_func(year_handler, years, parallel, num_workers=num_workers)

""" A context manager class for a lock which does not lock anything. """
class DummyLock:
    def __init__(self):
        pass

    def __enter__(self):
        return self

    def __exit__(self, *args):
        pass

""" Adapter classes for progressbars. """
class Bar:
    def __init__(self, parallel):
        self.counter = 0
        if parallel:
            self.lock = threading.Lock()
        else:
            self.lock = DummyLock()
        self.bar.start()

    def update(self):
        with self.lock:
            self.counter += 1
            self.bar.update(self.counter)

    def finish(self):
        self.bar.finish()

    def __call__(self, *args, **kwargs):
        return self.bar(*args, **kwargs)

class UnknownLengthBar(Bar):
    def __init__(self, parallel):
        self.bar = progressbar.ProgressBar(maxval=progressbar.UnknownLength)
        Bar.__init__(self, parallel)

class KnownLengthBar(Bar):
    def __init__(self, maxval, parallel):
        self.bar = progressbar.ProgressBar(maxval=maxval)
        Bar.__init__(self, parallel)
